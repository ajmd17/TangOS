#include <kernel/task.h>
#include <util/logging.h>

void switch_task(uint8_t reschedule) {
  if (!current_process) {
    /* Tasking is not yet installed. */
    return;
  }
  if (!current_process->running) {
    switch_next();
  }

  /* Collect the current kernel stack and instruction pointers */
  uintptr_t esp, ebp, eip;
  asm volatile ("mov %%esp, %0" : "=r" (esp));
  asm volatile ("mov %%ebp, %0" : "=r" (ebp));
  eip = read_eip();
  if (eip == 0x10000) {
    /* Returned from EIP after task switch, we have
     * finished switching. */
    fix_signal_stacks();

    /* XXX: Signals */
    if (!current_process->finished) {
      if (current_process->signal_queue->length > 0) {
        node_t * node = list_dequeue(current_process->signal_queue);
        signal_t * sig = node->value;
        free(node);
        handle_signal((process_t *)current_process, sig);
      }
    }

    return;
  }

  /* Remember this process' ESP/EBP/EIP */
  current_process->thread.eip = eip;
  current_process->thread.esp = esp;
  current_process->thread.ebp = ebp;
  current_process->running = 0;

  /* Save floating point state */
  switch_fpu();

  if (reschedule && current_process != kernel_idle_task) {
    /* And reinsert it into the ready queue */
    make_process_ready((process_t *)current_process);
  }

  /* Switch to the next task */
  switch_next();
}

/*
 * Immediately switch to the next task.
 *
 * Does not store the ESP/EBP/EIP of the current thread.
 */
void switch_next(void) {
  uintptr_t esp, ebp, eip;
  /* Get the next available process */
  current_process = next_ready_process();
  /* Retreive the ESP/EBP/EIP */
  eip = current_process->thread.eip;
  esp = current_process->thread.esp;
  ebp = current_process->thread.ebp;

  /* Validate */
  if ((eip < (uintptr_t)&code) || (eip > (uintptr_t)heap_end)) {
    debug_print(WARNING, "Skipping broken process %d! [eip=0x%x <0x%x or >0x%x]", current_process->id, eip, &code, &end);
    switch_next();
  }

  if (current_process->finished) {
    debug_print(WARNING, "Tried to switch to process %d, but it claims it is finished.", current_process->id);
    switch_next();
  }

  /* Set the page directory */
  current_directory = current_process->thread.page_directory;
  switch_page_directory(current_directory);
  /* Set the kernel stack in the TSS */
  set_kernel_stack(current_process->image.stack);

  if (current_process->started) {
    if (!current_process->signal_kstack) {
      if (current_process->signal_queue->length > 0) {
        current_process->signal_kstack  = malloc(KERNEL_STACK_SIZE);
        current_process->signal_state.esp = current_process->thread.esp;
        current_process->signal_state.eip = current_process->thread.eip;
        current_process->signal_state.ebp = current_process->thread.ebp;
        memcpy(current_process->signal_kstack, (void *)(current_process->image.stack - KERNEL_STACK_SIZE), KERNEL_STACK_SIZE);
      }
    }
  } else {
    current_process->started = 1;
  }

  current_process->running = 1;

  /* Jump, baby, jump */
  asm volatile (
      "mov %0, %%ebx\n"
      "mov %1, %%esp\n"
      "mov %2, %%ebp\n"
      "mov %3, %%cr3\n"
      "mov $0x10000, %%eax\n" /* read_eip() will return 0x10000 */
      "jmp *%%ebx"
      : : "r" (eip), "r" (esp), "r" (ebp), "r" (current_directory->physical_address)
      : "%ebx", "%esp", "%eax");
}